#coding:utf-8

import unicodedata
import bs4
from bs4 import BeautifulSoup as HtmlParse
from enum import Enum
from urllib.parse import urljoin
from urllib.parse import urlparse
from web import client
from db import fileDB
from db.classDB import ProjectDB
import time

def createNewDocs(path, projectName, version, language, iconhref):
    if not isJavaDocAccordingUrl(path):
        raise JavaDocNotFondError('`%s` not java doc url.' % path)
    baseUrl, allClass = searchAllClassHref(path)
    language   = __language(baseUrl)
    baseUrlLen = len(baseUrl[:baseUrl.rindex('/') + 1])
    prefix     = './static/doc/%s/%s/' % (projectName, version)
    project = ProjectDB((projectName, version, None, language, iconhref))

    try:
        for url in allClass:
            reallyUrl = url[baseUrlLen:]
            print(url)
            path      = prefix + reallyUrl
            __parseAndSaveOneClass(url, project, path, language, prefix)
    except Exception as e:
        project.rollback()
        raise(e)
    else:
        project.commit()

def isJavaDocAccordingUrl(url):
    content = client.getUTF8Content(url)
    return isJavaDocAccordingContent(content)

def isJavaDocAccordingContent(content):
    html = HtmlParse(content, 'html5lib')
    javaDocFlag = 'generated by javadoc'
    for i in range(3):
        if str(html.head.contents[i]).lower().strip().startswith(javaDocFlag):
            return True
    return False

def searchAllClassHref(url):
    content = client.getUTF8Content(url)
    html    = HtmlParse(content, 'html5lib')

    if not isJavaDocAccordingContent(content):
        errorMsg = 'If you ensure this is java doc url, Please mail to tianxuxin@126.com, tell me url `%s`.'
        raise JavaDocNotFondError(errorMsg % url)

    cssHref = urljoin(url, html.link['href']) if html('link') else url
    baseUrl = urljoin(cssHref, 'allclasses-frame.html')

    content = client.getUTF8Content(baseUrl)
    html    = HtmlParse(content, 'html5lib')
    return (baseUrl, (urljoin(baseUrl, item['href']) for item in html('a')))

def __language(baseUrl):
    html = client.html(baseUrl)
    allClassText = html.title.get_text().split()[0]
    return 'zh' if allClassText == '所有类' else 'en'

def __parseAndSaveOneClass(url, db, path, language, pathPrefix):
    errorTime = 0
    classId   = -1

    while True:
        try:
            content = client.getUTF8Content(url)
            html    = HtmlParse(content)

            metadata = __parseHtmlMetadata(html, path, language)
            __htmlStandardHandler(html)
            __replaceJSAndCSS(html, url, pathPrefix, path)

            classId  = db.insertOneClass(metadata)
            print('Insert class `%s` to db, id is `%d`' % (metadata[0][0], classId))
            fileDB.saveToSpecificPath(path, html.prettify())
            return
        except Exception as e:
            print('Error: insert to class.', e)
            errorTime += 1
            db.rollbackOneClass(classId)
            time.sleep(1)
            if errorTime >= 1:
                raise e

def __htmlStandardHandler(html):
    keySet = {'START OF TOP NAVBAR', 'START OF BOTTOM NAVBAR'}
    flag = False
    for item in html.body:
        if isinstance(item, bs4.element.Comment):
            flag = item.replace('=', '').strip().upper() in keySet
        if flag:
            item.extract()

def __replaceJSAndCSS(html, url, prefix, path):
    for item in (css for css in html('link') if css.has_attr('href')):
        item['href'] = __saveCssAndJs(url, item['href'], prefix, path)

    for item in (js for js in html('script') if js.has_attr('src')):
        item['src']  = __saveCssAndJs(url, item['src'], prefix, path)

    for item in (js for js in html('img') if js.has_attr('src')):
        item['src']  = __saveCssAndJs(url, item['src'], prefix, path)

def __saveCssAndJs(url, link, prefix, path):
    reallyLink   = None
    localPath    = None
    relativeLink = None

    if link.startswith('http'):
        reallyLink   = link
        localPath    = prefix + urlparse(reallyLink).path
        relativeLink = path[len(prefix):].count('/') * '../' + urlparse(reallyLink).path
    else:
        reallyLink   = urljoin(url, link)
        localPath    = urljoin(path, link)
        relativeLink = link

    if not fileDB.checkFileExist(localPath):
        content    = client.getContent(reallyLink)
        fileDB.saveToSpecificPath(localPath, content)
    return relativeLink

def __parseHtmlMetadata(html, classPath, language):
    members       = __extractDocMembers(html, classPath, language)

    classMETA     = __className(html) + (classPath, )
    fieldMETA     = __extractFieldsFromHtml(members)
    methodMETA    = [(item + ('method', )) for item in __extractMethodFromHtml(members)]
    methodMETA.extend([(item + ('constructor', )) for item in __extractConstructorsFromHtml(members)])
    return (classMETA, methodMETA, fieldMETA)

def __extractDocMembers(html, url, language):
    wordMap = {True:  {'en': '{0} summary table, listing {0}s, and an explanation',
                       'zh': '{0}概要表, 列表{0}和解释'},
               False: {'en': '{0} summary',
                       'zh': '{0}摘要'}
              }
    keyMap = {'method':      {'zh': '方法',
                              'en': 'method'},
              'field':       {'zh': '字段',
                              'en': 'field'},
              'constructor': {'zh': '构造方法',
                              'en': 'constructor'}
             }
    lang       = html.find('html').get('lang', language)
    upJDK7Flag = html.find('html').has_attr('lang')
    def member(key):
        keyWord  = wordMap[upJDK7Flag][lang].format(keyMap[key][lang])
        result = []
        for table in [item for item in html('table') if item.has_attr('summary')]:
            word = ''
            if upJDK7Flag:
                word = table['summary']
            elif table('b'):
                word = table('b')[0].get_text()
            else:
                continue
            if word.lower() == keyWord:
                result = table.tbody('tr', recursive=False)[1:]
        return (url, result)
    return member

def __className(html):
    href = html.find('a', attrs={'target' : '_top'})['href']
    partOfURI = href[href.index('?') + 1 : href.rindex('.html')]
    simple    = partOfURI[partOfURI.rindex('/') + 1:]
    full      = partOfURI.replace('/', '.')
    return (full, simple)

def __extractConstructorsFromHtml(member):
    url, trs = member('constructor')
    for tr in trs:
        lastTd = tr('td')[-1]
        code = lastTd.find('code')
        href = code.find('a')['href']
        text = ' '.join(code.get_text().split())
        text = __extractMethodWithoutParam(text)
        yield (text, urljoin(url, href))

def __extractFieldsFromHtml(members):
    url, trs = members('field')
    for tr in trs:
        td    = tr('td')[1]
        a_tag = td.find('a')
        yield (a_tag.get_text(), urljoin(url, a_tag['href']))

def __extractMethodFromHtml(members):
    url, trs = members('method')
    for tr in trs:
        sign = ' '.join(tr('td', recursive = False)[1].find('code').get_text().split())
        sign = __extractMethodWithoutParam(sign)
        href = tr('td', recursive=False)[1].find('a')['href']
        yield (sign, urljoin(url, href))


def __extractMethodWithoutParam(sign):
    p, l = sign.split('(')
    l = l[:-1]
    return '%s(%s)' % (p, ','.join(l.split()[::2]))

# JavaDoc.Exception
class Error(Exception):
    '''Base Error for this model'''
    pass

class JavaDocNotFondError(Error):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return self.value
